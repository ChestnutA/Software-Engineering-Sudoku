# 代码覆盖率
使用 `gcov` 和 `lcov`进行测试。
# 过程
我们针对程序的使用命令逐步进行测试。

**首先测试生成终局**
```shell
sudoku.exe -c 20
```
结果如下所示：
![](check0.png)
这里可以看到这个命令的代码覆盖率较低
![](check1.png)
仔细观察src的代码，发现覆盖率都不高
![](check2.png)
这里是由于我们的程序是集成的，因此在多个分支之间执行，必然会导致代码覆盖率较低

**然后测试解数独**
```shell
sudoku.exe -s game.txt
```
![](check3.png)

![](check4.png)
这里可以看出覆盖率有了一定的上升，同时solver的功能被覆盖最多。
![](check5.png)
我们仔细打开观察一下
![](check6.png)
这里我们发现，原来一些换行和括号并不会被gcov计算进去
![](check7.png)

**然后测试生成数独**
```shell
sudoku.exe -n 1000
```
![](check8.png)
这里我们发现头文件之中的函数原型都被调用了。
![](check9.png)
代码覆盖率也有了明显上升
![](check10.png)

**然后测试生成不同难度等级的数独**
```shell
sudoku.exe -n 1000 -m 3
```
![](check11.png)
可以发现代码覆盖率变得非常高，因为这几乎使用到了我们程序之中所需要和实现的大部分功能。
![](check12.png)
点开其中一个进行查看，可以发现几乎所有函数都被使用了。
![](check13.png)
**然后测试生成不同挖空数量的数独**
```shell
sudoku.exe -n 1000 -r 20-55
```
![](check14.png)
可以看到90%左右的代码覆盖率。
![](check15.png)
**最后测试生成唯一解的数独**
```shell
sudoku.exe -n 1000 -u
```
![](check16.png)
可以看到只有main.cpp的覆盖率与此前有所区别，其他的函数调用基本已经达到最多！
![](check17.png)
